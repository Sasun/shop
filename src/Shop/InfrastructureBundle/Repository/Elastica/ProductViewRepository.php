<?php

namespace Shop\InfrastructureBundle\Repository\Elastica;

use Elastica\Aggregation\Terms;
use Elastica\Filter\BoolAnd;
use Elastica\Filter\Range;
use Elastica\Filter\Term;
use Elastica\Query;
use Elastica\Query\Match;
use Elastica\ScanAndScroll;
use Elastica\Type;
use FOS\ElasticaBundle\Repository;
use Shop\Domain\Product\ProductView;
use Shop\Domain\Product\ProductViewRepository as BaseProductViewRepository;
use Shop\InfrastructureBundle\Transformer\ProductElasticaToModelTransformer;

class ProductViewRepository extends Repository implements BaseProductViewRepository
{
    /**
     * @var Type
     */
    private $type;

    /**
     * @var ProductElasticaToModelTransformer
     */
    private $transformer;

    public function setType(Type $type)
    {
        $this->type = $type;
    }

    public function setModelTransformer(ProductElasticaToModelTransformer $transformer)
    {
        $this->transformer = $transformer;
    }

    /**
     * @inheritdoc
     */
    public function findPaginatedByQueryAndCategory(
        \string $queryString = null,
        \string $category = null,
        \int $priceFrom = null,
        \int $priceTo = null,
        \bool $availability = null
    )
    {
        $queryObject = new Query();
        $filter = new BoolAnd();

        if ($queryString) {
            $query = new Match('_all', ['query' => $queryString, 'operator' => 'AND']);
        } else {
            $query = new Query\MatchAll();
        }

        if ($availability !== null) {
            $filter->addFilter(new Term(['availability' => $availability]));
        }

        $range = [];
        if ($priceFrom) {
            $range['gte'] = $priceFrom;
        }
        if ($priceTo) {
            $range['lte'] = $priceTo;
        }
        if ($range) {
            $filter->addFilter(new Range('price', $range));
        }

        if ($category) {
            $term = new Term(['category.id' => $category]);
            $queryObject->setPostFilter($term);
        }

        $terms = new Terms('categories');
        $terms->setField('category.id');
        $terms->setSize(0);
        $queryObject->addAggregation($terms);

        if ($filter->getFilters()) {
            $filtered = new Query\Filtered($query, $filter);
            $queryObject->setQuery($filtered);
        } else {
            $queryObject->setQuery($query);
        }
        $queryObject->setSort(['updated' => 'desc']);
        $queryObject->setMinScore(0.5);

        return $this->findPaginated($queryObject);
    }

    /**
     * @inheritdoc
     */
    public function findById(\string $id) : ProductView
    {
        $result = $this->type->getDocument($id);
        $product = $this->transformer->transformObject($result->getData());

        return $product;
    }

    /**
     * @inheritdoc
     */
    public function findByIds(array $ids): array
    {
        $query = new Query(new Query\Ids(null, $ids));

        return $this->find($query);
    }

    /**
     * @inheritdoc
     */
    public function getAvailability(\string $id): \bool
    {
        return $this->findById($id)->isAvailable();
    }

    /**
     * @inheritDoc
     */
    public function saveAvailability(\string $id, \bool $availability)
    {
        return;
    }

    /**
     * @inheritDoc
     */
    public function findAllIds()
    {
        $generator = function (ScanAndScroll $scanAndScroll) {
            foreach ($scanAndScroll as $scrollId => $resultSet) {
                foreach ($resultSet as $result) {
                    yield $result->getId();
                }
            }
        };
        $query = new Query(new Query\MatchAll());
        $query->setFields([]);
        $search = $this->type->createSearch($query);
        $scanAndScroll = new ScanAndScroll($search);

        return $generator($scanAndScroll);
    }

    /**
     * @inheritDoc
     */
    public function createPaginatorAdapter($query, $options = array())
    {
        return parent::createPaginatorAdapter($query, $options); // TODO: Change the autogenerated stub
    }
}